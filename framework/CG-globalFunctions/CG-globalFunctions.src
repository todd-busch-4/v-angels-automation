'#############################################################################################################################################################
'##  filename:				cg-globalFunctions
'##
'##  purpose:				library of general functions for use in caregiver workflow script development in order to minimize code duplication, increase
'##							script cleanliness/readability, and reduce maintenance efforts by providing a single centralized location for changes
'##
'#############################################################################################################################################################

'=============================================================================================================================================================
'== function name:           	zeroPadDate$
	'==
	'== developer:              todd busch
	'==
	'== purpose:                adds a leading zero to single digit day and month parts of a short formatted date (m/d/yyyy)
	'==
	'== input parms:            dt_date$:	date to be formatted (must be in short format)
	'==
	'== returns:                string:	the converted date with leading zeros
	'==
	'== notes:                  n/a
	'==
'=============================================================================================================================================================
function zeroPadDate$(dt_date$)
	local r, dt_date$, dtDay$, dtYr$, dtMo$

	'-------------------- parse date into parts
	'get day part
	dtDay$ = left$(dt_date$, 2)

	'get year part
	dtYr$ = right$(dt_date$, 4)

	'get month part
	r = instr(dt_date$, "/")
	dtMo$ = mid$(dt_date$, r + 1, 2)

	'add leading zero to day if single digit
	if instr(dtDay$, "/") <> 0 then
		dtDay$ = "0" + left$(dtDay$, 1)
	endif
	
	'add leading zero to day if single digit
	if instr(dtMo$, "/") <> 0 then
		dtMo$ = "0" + left$(dtMo$, 1)
	endif

	'reassmble date parts
	zeroPadDate$ = dtDay$ + "/" + dtMo$ + "/" + dtYr$

endfunction

'=============================================================================================================================================================
'== function name:           	formatSSN$
	'==
	'== developer:              todd busch
	'==
	'== purpose:                adds dashes to specified ssn if it does not have them
	'==
	'== input parms:            str_ssn$:	the ssn to be formatted
	'==
	'== returns:                string:		the formatted ssn with dashes
	'==
	'== notes:                  n/a
	'==
'=============================================================================================================================================================
function formatSSN$ (str_ssn$)
     local str_ssn$, middle$, pre$, post$
   
    if instr(str_ssn$, "-") = 0 then
        'divide # into parts
        pre$ = left$(str_ssn$, 3)
        middle$ = mid$(str_ssn$, 4, 2)
        post$ = right$(str_ssn$, 4)

        'assemble string    
        formatSSN$ = pre$ + "-" + middle$ + "-" + post$

    else
        formatSSN$ = str_ssn$
    endif

endfunction

'=============================================================================================================================================================
'== function name:           	nullDataElementChk
	'==
	'== developer:              todd busch
	'==
	'== purpose:                checks specified data element for a null value
	'==
	'== returns:                int:	0 - not null
	'==									1 - null value
	'==
	'== notes:                  none
	'==
'=============================================================================================================================================================
function nullDataElementChk(str_object$)
	local str_object$

	if str_object$ = "" or str_object$ = "[]" then
		write(debugLogPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": " + str_object$ + " did not contain a value for the current row", crlf)
		write(debugLogPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": resuming scan for next change event", crlf + crlf)
		write(executionLogPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": workflow failed; proceeding to next change event", crlf + crlf)
		write(scanFailuresPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": record id: " + applicantID$, crlf)
		write(scanFailuresPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": applicant: " + applicantFName$ + " " + applicantLName$, crlf)
		write(scanFailuresPath$, basicLogHdr$ + Time$() + ": " + currScript$ + ": nullDataElementChk: null value: [" + str_object$ + "]", crlf + crlf)
		nullDataElementChk = 1
		exitfunction
	else
		nullDataElementChk = 0
	endif

endfunction

'=============================================================================================================================================================
'== function name:           	convStateToName$
	'==
	'== developer:              todd busch
	'==
	'== purpose:                converts the specified state value from whatever the current form is to the capitalized name
	'==
	'== input parms:            str_state$:		the state value to convert
	'==
	'== returns:                str:			the capitalized state name (e.g. Ohio)
	'==
	'== notes:                  none
	'==
'=============================================================================================================================================================
function convStateToName$(str_state$)
	local str_state$

	if str_state$ = "OH" then
		convStateToName$ = "Ohio"
		exitfunction
	endif
	if str_state$ = "Oh" then
		convStateToName$ = "Ohio"
		exitfunction
	endif
	if str_state$ = "Ohio" then
		convStateToName$ = "Ohio"
		exitfunction
	endif
	if str_state$ = "OHIO" then
		convStateToName$ = "Ohio"
		exitfunction
	endif

endfunction

'=============================================================================================================================================================
'== function name:				convStateToCode$
	'==
	'== developer:              todd busch
	'==
	'== purpose:                converts the specified state value from whatever the current form is to the all caps state code
	'==
	'== input parms:            str_state$:		the state value to convert
	'==
	'== returns:                str:			the all caps state code (e.g. OH)
	'==
	'== notes:                  none
	'==
'=============================================================================================================================================================
function convStateToCode$(str_state$)
	local str_state$
	
	'-------------------- ohio
	if str_state$ = "OH" then
		convStateToCode$ = "OH"
		exitfunction
	endif
	if str_state$ = "Oh" then
		convStateToCode$ = "OH"
		exitfunction
	endif
	if str_state$ = "Ohio" then
		convStateToCode$ = "OH"
		exitfunction
	endif
	if str_state$ = "OHIO" then
		convStateToCode$ = "OH"
		exitfunction
	endif

	'-------------------- tennessee
	if str_state$ = "TN" then
		convStateToCode$ = "TN"
		exitfunction
	endif
	if str_state$ = "Tn" then
		convStateToCode$ = "TN"
		exitfunction
	endif
	if str_state$ = "Tennessee" then
		convStateToCode$ = "TN"
		exitfunction
	endif
	if str_state$ = "TENNESSEE" then
		convStateToCode$ = "TN"
		exitfunction
	endif


endfunction
